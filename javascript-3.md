# 数组和函数
## 数组的概述
### 为什么学习数组
之前学习的数据类型，只能存储一个值。（字符串为一个值）
我们想存储多个值的时候可以使用数组。（字符串不方便）
比如：存储班级中所有学生的姓名。（[“张三”,“李四”,“王五”]）
### 数组是什么

 数组是一种数据类型。（把很多数据装入一个盒子中，用的时候在取出来）
字面量为[1,2,3]。可以理解为：西瓜皮[]，西瓜肉123，西瓜子(，)
## 数组的定义
### 字面量定义
var  arr  =  [1,2,3];
### 对象定义（数组的构造函数）
var  arr  =  new Array(参数);
参数位置一个数值时为数组长度，多个数值时为数组中的元素。
## 数组的操作
### 求数组的长度
数组的长度 =  数组名.length；
可以通过修改数组的长度来改变数组中元素的个数，如果改小了，数组从后面删除元素。（伪数组的长度可以修改，但是不能修改里面的元素）
### 获取数组中的元素
数组中的指定元素 = 数组名[索引值];
数组的索引代表的是数组中的元素在数组中的位置，从0开始。
如果获取数组中元素是，数组名[索引值]，没有指定索引（元素没那么多），系统不报错，而是给定值为undefined；
## 遍历数组（获取并操作数组中的每一个元素）（！！！重点！！！）


```
var arr = [1,2,3];
for(var i = 0;i<arr.length;i++){
    arr[i]  //如此操作数组中的每一个元素
}
```




## 调试（打断点）
一、过去的调试（锻炼逻辑能力）
alert(变量);     console.log(变量);
二、设置断点（项目太大，使用断点方便）

## 函数概述
* 什么是函数
函数就是可以重复执行的代码块。
* 为什么要用函数
因为一部分代码使用次数可能会很多，所以封装起来，需要的时候调用就可以了。
案例：求和；（总是求和）
### 函数的定义
关键字function。
function 函数名 ()  {  程序   }
### 参数
参与运算的变量。
为什么要设置参数？为了增强函数的功能性，和程序员的交互性，和函数的可拓展行。所以我们增加了参数这个概念。
* 形参

形式上参与运算的变量，无实际值，为实参占位置，就像一`个躯壳一样。（可以理解为函数的内部变量外部无法访问）
* 实参
实际参与运算的变量。形参为他占位置，真实参与运算的变量。
### 返回值
有return函数就有值；没有return函数就没值；
函数程序运行后的结果外部需要使用的时候，我们不能直接给与，需要通过return返回。
总结：函数内部，return后面的值就是返回值；
作用：函数执行后剩下结果就是返回值。
函数执行完毕，会不会留下点儿什么，取决于有没有返回值


```
		var  temp   =    函数名()   =  （功能）+ 该函数的返回值;
```


#### 注意
1. 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined
2. 如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值
3. 如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值	也是：undefined
4. 函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退	出，也就是说return后面的所有其他代码都不会再执行。

### 函数名、函数体和函数加载问题（重点记忆）
1、函数名是什么
函数名 == 整个函数。


```
function fn(){alert(1)};
console.log(fn) == console.log(function fn(){alert(1)});
```


2、函数加载问题
JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。

### 函数定义
#### 函数声明（自定义声明）
  

```
function f(a,b) {
        return a + b; }
  console.log(f(5,6));
```


#### 函数表达式
    

```
var myFun = function (a,b){
        return a + b;
    }
    console.log(myFun(6,7));
```


### 变量和作用域（隐式全局变量和变量声明提升）
#### 变量和作用域（函数中的变量需要函数执行后才能使用）
一、全局变量（成员变量）
哪里都可以访问到的变量。
（进入script立即定义的变量和没有var的变量）
二、局部变量
函数内部的变量，只有函数内部可以访问到。
（函数内部用var定义的变量和形参）
#### 隐式全局变量
隐式全局变量就是隐藏的全局变量不好被发现。


```
function  fn（）{
var  a  =  b  =  c  =  1;   // b和c就是隐式全局变量
}
注意:
function  fn（）{
var  a  =  b  =  c  =  1;   // b和c就是隐式全局变量（等号）
var  a = 1;  b = 2;  c = 3;     // b和c就是隐式全局变量（分号）
var  a = 1 ,  b = 2 ,  c = 3;    // b和c就不是隐式全局变量（逗号）
}
```


#### 变量声明提升（出现原因：预解析）
函数中，定义变量在使用变量之后。
值提升变量名，不提升变量值，容易出现undefined。计算后形成NaN。


```
function fn(){
// var aaa;
console.log(aaa);
var aaa = 1;
}
```


* 提前看一眼这个习惯叫什么呢？  预解析！
* 变量声明提升：在预解析的时候，成员变量和函数，被提升到最高位置，方便其他程序访问。
* 变量声明提升特点：成员变量只提升变量名，不提升变量值。但是，函数是所有内容全部提升。（function直接定义的）
* 函数范围内照样会出现变量声明提升
* 什么情况容易出现变量声明提升：使用变量在定义变量之前。



