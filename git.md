# Git
### Git工作原理
为了更好的学习Git，我们们必须了解Git管理我们文件的3种状态，分别是已提交（committed）、已修改（modified）和已暂存（staged），由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。
Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。 这是Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。
工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index），不过一般说法还是叫暂存区域。

**基本的Git工作流程如下：**
	1、在工作目录中修改文件。
	2、暂存文件，将文件的快照放入暂存区域。
	3、提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。
### Git本地仓库
Git本地仓库指的是开发者开发设备中的仓库。
#### Git基础
命令行方式：任意目录（建议开发根目录）右键 > Git Bash Here
* 配置用户
配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为，如lion于2016-08-24解决了一个bug。
`git config --global user.name "自已的名字"`
`git config --global user.email "自已的邮箱地址"`
`--global` 配置当前用户所有仓库
`--system` 配置当前计算机上所有用户的所有仓库
注：配置用户只需要执行1次，可以重复使用。
* 初始化仓库
我们如果想要利用git进行版本控制，需要将现有项目初始化为一个仓库，或者将一个已有的使用git进行版本控制的仓库克隆到本地。
a) `git init`

`git ini`t只是创建了一个名为.git的隐藏目录，这个目录就是存储我们历史版本的仓库，ls -al 可以查看。

b) 假如公司已有项目用了Git，那我们就利用克隆
`git clone 仓库地址`

执行完这个命令，会在当前目录下生成一个Monment目录（默认和仓库名称相同），这个便是已有一个使用Git管理的项目。

* 查看文件状态
初始化仓库后便可以进行开发了，进入到刚刚创建好并初始为仓库的目录，添加我们开发需要的文件。
通过`git status`可以检测当前仓库文件的状态

**注：git会忽略空的目录**
* 添加文件到暂存区
假设经过一段时间的开发后，需要把已开发的部分存起来，使用git add 添加到暂存区。
`git add 文件名/ 文件路径 `“*”或-A代表所有

放到暂存区的文件被标记成了绿色，等待提交。
注：颜色是工具给添加的，目的是增加可读性并不是git统一的。
* 撤销更改
继续我们的开发
再次git status可以再次查看仓库状态

说明index.html再次被修改了，并被标记了红色。
又经过一段时间后发现新开发的部分有Bug，想要回到之前状态，可以使用git checkout 文件名。

**注：从暂存区还原原到工作区**
* 提交文件
经过一个相对较长阶段开发或者一个功能开发完成了，就可以提交到本地仓库了，永久保存了。
git commit -m '备注信息'

将暂存区被标记成绿色的文件，全部提交到本地仓库存储。
这时git status查看状态

没有什么可提交的，变的很干净。
* 查看提交历史
反反复复开发了很多的功能了，通过git log查看一下提交的历史。

我们可以查看到一次次提交记录
`commit 81b1e4fc2ae178caedf4575596377a80a6f1e73f`
代表一次提交的唯一ID，一般称为SHA值。傻？
**注：按键盘q键退出。**
* 再次检测仓库文件状态
隔了好些天后，继续开发
git status 查看状态

又提示有修改，等待重新添加到暂存区。
* 重新添加暂存区然后提交

* 再次查看历史
`git log`可查到所有提交历史

这时可以查看到更多提交历史。
这时关掉所有目录甚至关机！
* 恢复上一次提交的状态
通过SHA值可以回到之前某一次的提交（时光倒流）
`git reset --hard c888a614e072e2`这样便回到了支付功能的状态
git log再次查看发现最后一次提交成了支付功能了


### Git分支
在我们的现实开发中，需求往往是五花八门的，同时开发个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要你来修复，这个时候我们当然是希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。如何实现呢？
通过Git创建分支来解决实际开发中类似的问题。
在Git的使用过程中一次提交称为历史记录（版本），并且会生成一个唯一的字符串，如下图

这个串可以代表某一个历史版本（实际使用只取前面几位就可以），
值得注意的是所有的提交（commit）实际上都是在分支（branch）的基础上进行的。
如下图所示：

当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个master的分支，并且有指针（HEAD）指到了末端。
指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。
我们也可以创建自已的分支
1、创建分支
`git branch hotfix`
新的分支会在当前分支原有历史版本的结点上进行创建，我称其为子分支如下图

新建的子分支会继承父分支的所有提交历史。
2、切换分支
`git checkout hotfix`

我们发现HEAD现在又指向了hotfix的末端。
3、再次提交操作
修改bug后，提交

这次的提交历史版本就会记录在hotfix这个分支上了，并且HEAD伴随hotfix在移动。
4、当我们再次切回到master时

当我们切换回master后，HEAD指向了master分支的末端，并且我们观察发现我们的文件内容还是原来的“模样”。
5、继续之前的开发

总结：当我们`git checkout branchname`时，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。
这个时候我们就在hotfix这个分支上修复了这个BUG，而我们原来在master分支上的操作并未受到影响。
思考一个问题：
现在master这个分支上是否包含了hotfix的修复呢？
实际上从上图可以看出这时的master分支并没有包含有hotfix的修复。
6、合并（融合）分支
`Git merge master(被合并到主分支上)`


这时master会有两个父结点了，master便包含了hotfix里的修复了
7、删除分支
`git branch -d hotfix`
这时用来修复BUG创建的hotfix分支已经没有用处了，我们可以将它删除。

3.4Git远程（共享）仓库
通过上面学习我们可以很好的管理本地版本控制了，可是如果我们下班回到家里突然来了灵感觉得有部分代码可以优化，如果能接着公司电脑上的代码继续写该有多好呀！另一种情形，假设项目比较大，不同的功能模块由不同的开发人员完成，不同模块儿之间又难免会依赖关系，这时如果我们的代码互相合并（融合）该有多好呀！所有模块开发完毕后，需要整合到一起，要能做到准确无误该有多好呀！
借助一个远程仓库，大家可以共享代码、历史版本等数据，便可以解决以上遇到的所有问题，在学习远程仓库前我们先来学习git clone path这个命令。
3、创建共享仓库
Git要求共享仓库是一个以.git结尾的目录。
`mkdir repo.git `创建以.git结尾目录
`cd repo.git `进入这个目录
`git init --bare `初始化一个共享仓库，也叫裸仓库 注意选项--bare

这样我们就建好了一个共享的仓库，但这时这个仓库是一个空的仓库，并且不允在这个仓库中进行任何修改。
4、向共享仓库共享（同步）内容
将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。
1、进入到yike目录
2、`git push ../repo.git master`

这样便把yike中的项目同步进了repo.git中。
5、从共享仓库里取出内容（clone或）
1、新创建一个目录（模拟另一个开发者）
2、`git clone ./repo.git demo`

通过repo.git共享仓库，我们轻松得到了一个yike的副本
6、通过demo仓库向repo.git共享内容
进入到demo里，我们做一些修改
`cd demo`
`git push ../repo.git master`

7、在360仓库从repo.git获取共享的内容
`cd yike`
`git pull ../repo.git master`

奇迹似乎发生了，我们轻松的将demo仓库里的内容，通过repo.git共享给了yike仓库。
惊喜不断，问题也总是不断，我们发现我们这个共享的仓库只是放到了本地的，其它人是没有办法从我们这个共享仓库共享内容的！！！
然而现实是，办法总是有的！！！！
我们把这个共享的仓库放到一台远程服务器上，问题不就解决了吗？